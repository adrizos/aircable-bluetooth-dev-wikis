@ERASE

0 REM this is the base code for all the AIRcable OS products
0 REM we take the AIRcable SMD/Mini as our base device

0 REM moved from UART command line to SPP as default.

0 REM let's reserve the first 30 lines for internal stuff

0 REM $1 is the version of the command line
1 0.6

0 REM defaults setting for mode
0 REM uncomment the one you want to use as default
0 REM service slave
2 1110
0 REM service master 3110
0 REM cable slave 1010
0 REM cable master 3010
0 REM idle 0010

0 REM $3 stores the mode configuration
0 REM $3[0] = 0 48 means idle
0 REM $3[0] = 1 49 means pairing as slave
0 REM $3[0] = 2 50 means paired as slave
0 REM $3[0] = 3 51 means pairing as master
0 REM $3[0] = 4 52 means paired as master
0 REM $3[0] = 5 53 means relay pairing
0 REM $3[0] = 6 54 means relay paired
0 REM $3[0] = 7 55 means relay slave connected, master connecting
0 REM $3[0] = 8 56 means relay connected

0 REM $3[1] = 0 48 cable mode
0 REM $3[1] = 1 49 service mode
0 REM $3[1] = 2 50 relay mode

0 REM $3[2] = 0 48 device found / module paired
0 REM $3[2] = 1 49 inquiry needed

0 REM the numbers that are missing had been removed, camed from UART
0 REM $3[3] = 0 48 means automatic
0 REM $3[3] = 1 49 means manual idle.
0 REM $3[3] = 3 51 manual inq
0 REM $3[3] = 4 52 manual master, connecting
0 REM $3[3] = 6 54 manual master, connected
0 REM $3[3] = 7 55 relay pairing

0 REM $3[4] = 1 49 means service relay mode
0 REM $3[4] = 2 50 means cable relay mode

0 REM $3[5] stores previous mode when accessing SPP command line.

0 REM if var K = 1 then we must do a slave-1

0 REM $3[4] is the amount of time we trigger alarms while on manual
0 REM need service-master mode, does not store pairing information starts 
0 REM with pairing
3 Z

0 REM $4 IS RESERVED FOR PAIRED ADDR
4 0

0 REM $5 stores the name of the devices we only want during inquiry
5 AIRcable

0 REM $6 stores the filter address we filter on during inquiry
6 00A8FFFFFF

0 REM $7 for paired master addresses
7 0

0 REM $8 stores the pio settings
0 REM $8[0] BLUE LED
0 REM $8[1] GREEN LED
0 REM $8[2] BUTTON
0 REM $8[3] RS232 POWER OFF
0 REM $8[4] RS232 POWER ON
0 REM $8[5] DTR
0 REM $8[6] DSR
0 REM $8[7] POWER SWITCH
0 REM $8[8] COMMAND LINE PIN
0 REM $8[9] BATTERY MEASURMENT ENABLED 0 - 1
0 REM LINE $12 STORES THE DEFAULT VALUE
0 REM z means unitializated
8 z

0 REM Debug settings
0 REM first char is for Z enabled/disabled
0 REM second is for dumping states
0 REM third for Obex/ObexFTP
0 REM 0 48 Enabled only on command line
0 REM 1 49 Always enabled
0 REM 2 50 Always Disabled
9 000

0 REM $10 stores our friendly name
10 AIRcableSMD

0 REM $11 stores our PIN
11 1234

0 REM DEFAULT pio settings IN ORDER
0 REM BLUE LED
0 REM GREEN LED
0 REM BUTTON
0 REM RS232 POWER OFF
0 REM RS232 POWER ON
0 REM DTR
0 REM DSR
0 REM POWER SWITCH
0 REM COMMAND LINE PIN
0 REM BATERY MEASURMENT ENABLED
12 K000000000

0 REM PIO_IRQ SETTINGS
0 REM $13 Button + Power Switch + Command Line. For no connections
0 REM autogenerated in first bootup
13 0
0 REM $14 button + DSR interrupt + Power Switch. While connected
0 REM autogenerated in first bootup
14 0

0 REM 15 is the settings for the uart when a connection is made
0 REM 0 means read from dip swithces
0 REM any other number is converted to an int.
15 1152

0 REM 16 this is the time that the Obex/ObexFTP will be available after
0 REM boot up
16 120

0 REM on variable we store the baud rate setting.
0 REM this variable is initializated by @SENSOR
0 REM and is not set until a connection is stablished


0 REM $20 is used for relay mode, it stores the master address
20 000000000000

0 REM $21 PIO_IRQ for off mode, only Power Switch measurment.
21 0

0 REM 22 Parity Settings
0 REM [0] = "0" = none
0 REM "1" = even
0 REM "2" = odd
0 REM [1] = "0" 1 stop bit
0 REM "1" 2 stop bits
22 00

0 REM 23 unique settings
0 REM [0] = "0" don't add nothing
0 REM [0] = "1" add unique name
0 REM [0] = "2" add unique name, generate pin
23 1

0 REM $39 RESERVED
39 RESERVED

0 REM THIS TURNS A CHAR AT $0[E] into
0 REM and integer in F
40 IF $0[E] > 57 THEN 43
41 F = $0[E] - 48;
42 RETURN
0 REM WE NEED TO ADD 10 BECAUSE "A" IS NOT 0
0 REM IS 10
43 F = $0[E] - 55;
44 RETURN


@INIT 45
45 Z = $9[0] - 48;
46 A = baud 1152
47 IF $9[1] = 48 THEN 49
48 PRINTS "@INIT\n\r";
49 IF $8[0] <> 122 THEN 73

0 REM first boot.
50 $0[0] = 0
51 PRINTV $12
52 FOR E = 0 TO 9
53 GOSUB 40
54 $8[E] = F + 48
55 NEXT E
56 $8[E+1] = 0
57 $0[0] = 0;
58 PRINTV"P000000000000";
59 $13 = $0;
60 $14 = $0;
61 $21 = $0;

62 IF $8[2] = 48 THEN 65;
63 $13[$8[2]-48] = 49;
64 $14[$8[2]-48] = 49;
65 IF $8[6] = 48 THEN 67;
66 $14[$8[6]-48] = 49;
67 IF $8[7] = 48 THEN 71;
68 $13[$8[7]-48] = 49;
69 $14[$8[7]-48] = 49;
70 $21[$8[7]-48] = 49;
71 IF $8[8] = 48 THEN 73;
72 $13[$8[8]-48] = 49;

73 GOSUB 951

74 H = 1

0 REM button as input
75 A = pioin ($8[2]-48);
0 REM bias pull up to high
76 A = pioset ($8[2]-48);
0 REM green LED output, off
77 A=pioout ($8[1]-48);
78 A=pioclr ($8[1]-48);
0 REM blue LED output, off
79 A=pioout ($8[0]-48)
0 REM RS232_off set, switch on RS232
80 A=pioout ($8[3]-48)
81 A=pioset ($8[3]-48)
0 REM RS232_on power on, switch to automatic later
82 A=pioout ($8[4]-48)
83 A=pioset ($8[4]-48)
0 REM DTR output set -5V
84 A=pioout ($8[5]-48)
85 A=pioset ($8[5]-48)
0 REM DSR input
0 REM this line is changed by serial OS code, so update
86 A=pioin ($8[6]-48)
0 REM Command line Enable switch
87 A = pioin ($8[8]-48)
88 A = pioset ($8[8]-48)

0 REM start baud rate
0 REM 80 A = uartcfg 136
0 REM 81 A = nextsns 6
0 REM reset for pairing timeout
89 A = zerocnt
90 IF $9[1] = 48 THEN 92
91 PRINTS "Command Line ready

0 REM state initialize
92 IF $3[0] <> 90 THEN 94
0 REM newly updated BASIC program, goto SLAVE mode
93 $3 = $2;

0 REM init button state
94 W = 0

0 REM blue LED off
95 A = pioclr ($8[0]-48)
96 J = 0

97 $3[3] = 48;

0 REM should go to mode dump
98 IF $9[1] = 48 THEN 100
99 GOSUB 706

0 REM let's start up, green LED on
100 A = pioset ($8[1]-48)

101 K = 1
102 H = 1
103 M = 0
104 IF H = 0 THEN 114
105 IF $8[7] = 48 THEN 111
0 REM power switch detecting.
106 A = pioset ($8[7]-48)
107 A = pioin ($8[7]-48)
108 WAIT 1
109 A = pioget ($8[7]-48);
110 IF A = 0 THEN 116;
111 H = 0;
112 L = 1
113 N = 0;
0 REM set PIO_IRQ to not connected mode
114 A=pioirq $13
115 RETURN

0 REM we just got back from a reboot, with the power switch off.
0 REM then we turn off:
0 REM 	alarms
0 REM 	sensors
0 REM 	uart interrupt
0 REM 	and go invisible
116 M = 1;
117 ALARM 0;
118 A = nextsns 0;
119 A = pioclr ($8[0]-48);
120 A = pioclr ($8[1]-48);
121 A = pioclr ($8[2]-48);
122 A = pioclr ($8[3]-48);
123 A = pioclr ($8[4]-48);
124 A = pioclr ($8[5]-48);
125 A = pioclr ($8[6]-48);
126 A = slave -1
127 A = disable 3
128 A = pioirq $21;
129 RETURN


0 REM Obex/ObexFTP timing handler
0 REM this code is also called from the command line on exit
130 B = readcnt
131 C = atoi $16
132 IF B < C THEN 139
133 GOSUB 137
134 H = 0
135 GOTO 359

136 IF $9[2] = 49 THEN 138
137 A = disable 3
138 RETURN

139 ALARM 30
140 GOTO 359

@SENSOR 141
141 IF $22[2] > 48 THEN 154
142 IF $8[9] = 48 THEN 153
143 A = sensor $0
144 V = atoi $0[5]
145 A = nextsns 600
146 IF V < 3000 THEN 148
147 GOTO 151

148 N = 1
149 ALARM 5
150 GOTO 153

151 N = 0
152 ALARM 5
153 RETURN
0 REM baud rate selector switch implementation
0 REM thresholds (medians) for BAUD rate switch
0 REM AIO0 has voltage, use 1000 (3e8) as analog correction factor
0 REM if it is smaller than this, then switch is set
0 REM voltages: 160, 450, 650, 810, 930, 1020, 1090, >
0 REM switch    111, 110, 101, 100, 011,  010,  001, 000
0 REM baud:    1152,  96, 384, 000, 576,   48,  192, 321
154 $22[2] = $22[2] -1
155 IF $15[0] = 48 THEN 160;
0 REM we need to convert from string to integer, because we are on internal
0 REM baud rate, if an error ocurs while converting, then we switch
0 REM to the dip's automatically
156 C = atoi $15;
157 IF C = 0 THEN 160;
158 I = C;
159 GOTO 185
160 C = sensor $0;
161 IF C < 160 THEN 170;
162 IF C < 450 THEN 172;
163 IF C < 650 THEN 174;
164 IF C < 810 THEN 176;
165 IF C < 930 THEN 178;
166 IF C < 1020 THEN 180;
167 IF C < 1090 THEN 182;
168 I = 321;
169 GOTO 198;

170 I = 8;
171 GOTO 225;
172 I = 3;
173 GOTO 225;
174 I = 5;
175 GOTO 225;
176 I = 1152;
177 GOTO 159;
178 I = 6;
179 GOTO 225;
180 I = 2;
181 GOTO 225;
182 I = 4;
183 GOTO 225;

184 RETURN

185 IF I = 12 THEN 200
186 IF I = 24 THEN 202
187 IF I = 48 THEN 204
188 IF I = 96 THEN 206
189 IF I = 208 THEN 208
190 IF I = 384 THEN 210
191 IF I = 576 THEN 212
192 IF I = 769 THEN 214
193 IF I = 1152 THEN 216
194 IF I = 2304 THEN 218
195 IF I = 4608 THEN 220
196 IF I = 9216 THEN 222
197 IF I = 13824 THEN 224
0 REM wrong settings for baud rate, we don't have a fixed value, we can't do
0 REM parity and stop bits
198 A = baud I
199 RETURN

200 I = 0
201 GOTO 225
202 I = 1
203 GOTO 225
204 I = 2
205 GOTO 225
206 I = 3
207 GOTO 225
208 I = 4
209 GOTO 225
210 I = 5
211 GOTO 225
212 I = 6
213 GOTO 225
214 I = 7
215 GOTO 225
216 I = 8
217 GOTO 225
218 I = 9
219 GOTO 225
220 I = 10
221 GOTO 225
222 I = 11
223 GOTO 225
224 I = 12

225 IF $22[0] = 49 THEN 228
226 IF $22[0] = 50 THEN 230
227 GOTO 231
228 I = I + 64
229 GOTO 231
230 I = I + 32
231 IF $22[1] = 49 THEN 234
232 GOTO 234
233 I = I + 16
234 I = I + 128
235 A = uartcfg I
236 RETURN


0 REM handle button press and DSR, status is $0
@PIO_IRQ 237
237 IF $9[1] = 48 THEN 252;
238 PRINTS "PIO_IRQ\n\r"
239 PRINTS $0

240 IF L = 1 THEN 251
241 IF $8[7] = 48 THEN 252
242 A = pioget ($8[7]-48)
243 IF A = 1 THEN 247

0 REM we were turned off reboot.
0 REM when we boot up again, we turn off anything.
244 A = reboot
245 WAIT 3
246 RETURN


247 IF M = 0 THEN 252
0 REM we were turn on, reboot and start up everything on again.
248 A = reboot
249 WAIT 3
250 RETURN

251 L = 0

252 A = pioget($8[8]-48);
253 IF A = 1 THEN 255
254 ALARM 1

0 REM press button starts alarm for long press recognition
255 IF $0[$8[2]-48]=48THEN293
0 REM speaciall tratement for Button release on rebooting
256 IF W = 3 THEN 184
0 REM was it a release, now handle it
257 IF W <> 0 THEN 266

0 REM button no pressed, button not released
0 REM when DSR on the RS232 changes
258 IF $0[$8[6]-48]=48THEN261;
259 IF $0[$8[6]-48]=49THEN263;
260 RETURN
0 REM modem control to the other side
261 A = modemctl 0;
262 RETURN
263 A = modemctl 1;
264 RETURN

0 REM released with W == 2, alarm already handled it, exit
265 IF W = 2 THEN 289

0 REM this is a short button press
0 REM if we are on idle mode, then we switch to cable slave
0 REM if we are on service or cable unnconnected then switch master <-> slave
0 REM there is a slight difference between this spec, and the last one
0 REM on the last one any button press while on service did nothing.
266 B = status;
267 IF B < 10000 THEN 269;
268 B = B - 10000;
269 IF B > 0 THEN 298;
270 IF $3[0] = 48 THEN 280;
271 IF $3[0] > 50 THEN 280;

0 REM we were slave, now lets go to master.
272 ALARM 0
273 IF $9[1] = 48 THEN 275;
274 PRINTS "-> pair as master";
275 $3[0] = 51;
276 W = 0;
277 B = zerocnt;
278 A = slave-1
279 RETURN

0 REM switch to pair as slave
280 ALARM 0
281 IF $9[1] = 48 THEN 283
282 PRINTS "-> pair as slave\n"
283 $3[0] = 49
284 W = 0
285 A = zerocnt;
0 REM cancel inquiries
286 A = cancel
287 ALARM 1
288 RETURN

289 IF $9[1] = 48 THEN 291
290 PRINTS"Handled, ignore\n\r"
291 W = 0
292 RETURN


0 REM button press, recognize it and start ALARM for long press
293 IF $9[1] = 48 THEN 295
294 PRINTS "Button press\n\r"
295 W = 1
296 ALARM 3
297 RETURN

298 IF $9[1] = 48 THEN 300
299 PRINTS "Short, Connected
300 W = 0
301 RETURN

0 REM idle will be called, when the command line ends working
0 REM when the slave connection is closed, and when slave calls
0 REM timeouts, in any of those cases we will let the @ALARM
0 REM handle the slave mode stuff
0 REM idle used for slave connections, pairing or paired
@IDLE 302
302 L = 0
303 IF M = 0 THEN 305
0 REM IF M = 1 THEN we are turning off
304 RETURN

305 IF $3[3] <> 48 THEN 991;
306 IF $3[0] > 52 THEN 314;
307 IF W <> 0 THEN 492;
308 IF K = 1 THEN 311;
309 IF K = 2 THEN 312;
0 REM lets trigger the alarm manually
310 GOTO 342;


311 A = slave-1
312 K = 0;
313 RETURN

314 IF $3[0] = 53 THEN 326
315 IF $3[0] = 54 THEN 320
316 IF $3[0] = 55 THEN 327
317 A = disconnect 1
318 $3[0] = 54
319 B = status
320 IF B > 0 THEN 322
321 GOSUB 925
322 A = pioset ($8[1]-48);
323 A = pioset ($8[0]-48)
324 A = pioclr ($8[0]-48)
325 ALARM 9
326 RETURN

327 A = pioset ($8[0]-48);
328 A = pioset ($8[1]-48)
329 A = pioclr ($8[1]-48);
330 B = status
331 IF B > 1 THEN 333
332 A = master $20
333 ALARM 4
334 RETURN

@PIN_CODE 335
335 IF $9[1] = 48 THEN 337
336 PRINTS "@PIN_CODE"
337 IF $23[0] = 50 THEN 340
338 $0=$11;
339 RETURN
340 A = getuniq $0
341 RETURN

0 REM ALARM code, handles modes stuff, LEDs and long button press 
@ALARM 342
342 IF $9[1] = 48 THEN 344
343 PRINTS "@ALARM\n\r";

344 IF N = 0 THEN 347
345 A = pioclr ($8[1]-48)
346 A = pioset ($8[1]-48);

0 REM are we on automatic or manual?
347 IF $3[3] <> 48 THEN 832

0 REM check if the command line is accesible or not.

348 A = pioget($8[8]-48);
349 IF A = 1 THEN 355

0 REM Command Line is accessible.
350 GOTO 982

0 REM handle button press first of all.
355 IF W = 1 THEN 391

0 REM should go to mode dumping
356 IF $9[1] = 48 THEN 358
357 GOSUB 706

358 IF H = 1 THEN 130

359 IF $3[0] > 52 THEN 886

0 REM now the led stuff, and finally we handle the state.
0 REM firstly see if we are connected, then do what you need
360 B = status;
361 IF B < 10000 THEN 363;
362 B = B - 10000;
363 IF B > 0 THEN 365;
364 GOTO 369
0 REM ensure the leds are on
365 A = pioset ($8[0]-48);
366 A = pioset ($8[1]-48);
367 ALARM 5
368 RETURN


0 REM we are on automatic.
0 REM are we on automatic - manual?
369 IF $3[0] = 48 THEN 386

0 REM LED SCHEMA:
0 REM CABLE 	SLAVE 	1 fast blink
0 REM SERVICE 	SLAVE 	2 fast blink
0 REM CABLE	MASTER 	3 fast blink
0 REM SERVICE	MASTER 	4 fast blink
370 A = pioset ($8[1]-48);
371 A = pioset ($8[0]-48)
372 A = pioclr ($8[0]-48);
0 REM are we on master or slave?
373 IF $3[0] > 50 THEN 378
0 REM ok we are on slave
0 REM CABLE 	SLAVE 1 fast BLINK
0 REM SERVICE 	SLAVE 2 fast BLINK

0 REM now are we on cable or service?
374 IF $3[1] = 48 THEN 431
0 REM service slave
375 A = pioset ($8[0]-48)
376 A = pioclr ($8[0]-48);
377 GOTO 418;

0 REM we are on master modes
378 FOR B = 0 TO 1
379 A = pioset ($8[0]-48)
380 A = pioclr ($8[0]-48
381 NEXT B
382 IF $3[1] = 48 THEN 431;
383 A = pioset ($8[0]-48)
384 A = pioclr ($8[0]-48);
385 GOTO 420;


0 REM manual idle code, this is the only mode that ends here.
386 B = pioset ($8[1]-48);
387 B = pioclr ($8[0]-48);
388 A = slave-1
389 K = 2
390 RETURN

0 REM this is a long button press, we have stuff to do
0 REM if we are connected, then we disconnect and reboot to unpaired
0 REM if we aren't then we must reboot and go to idle mode.
391 GOSUB 932;
392 W = 2
393 IF $39[3] = 49 THEN 405
394 IF $39[4] = 49 THEN 405

0 REM reboot 
395 $3[0] = 48
396 $3[1] = 48
397 IF $9[1] = 48 THEN 399
398 PRINTS"->Reboot\n\r";
399 A = pioclr($8[0]-48);
400 A = pioclr($8[1]-48);
401 W = 3
402 A = reboot
403 WAIT 3;
404 RETURN

0 REM disconnects, disconnect restarts @IDLE
405 ALARM 0
406 IF $9[1] = 48 THEN 408
407 PRINTS "-> Discconnect\n\r"
0 REM if we were paired, then we must unpair.
408 IF $3[0] = 50 THEN 411
409 IF $3[0] = 52 THEN 411
410 GOTO 412;
411 $3[0] = ($3[0] -1)
0 REM 307 A = disconnect 0
0 REM 308 A = disconnect 1
0 REM 309 A = cancel
412 $7 = "0"
413 GOTO 397

0 REM cable mode timeout
414 IF $9[1] = 48 THEN 416
415 PRINTS "Timeout\n\r";
416 ALARM 0;
417 GOTO 386;

0 REM automatic modes code.
0 REM service - slave:
418 A = slave 5
419 RETURN

0 REM service - master
420 A = strlen $7;
421 IF A > 1 THEN 425
422 A = inquiry 6
423 ALARM 8
424 RETURN

425 A = master $7
426 IF $3[1] = 48 THEN 428
427 $7 = "0"
0 REM master returns 0 if the connection was succesfull
0 REM or if we are still trying to connect.
428 IF A = 0 THEN 365
429 ALARM 8
430 RETURN

0 REM cable code, if we are not paired check for timeout.
431 IF $3[0] = 50 THEN 437
432 IF $3[0] = 52 THEN 425
433 B = readcnt
434 IF B > 120 THEN 414
435 IF $3[0] = 49 THEN 418
0 REM we are pairing as master,
436 GOTO 422;

437 A = slave -5
438 RETURN


0 REM this interrupt is launched when there is an incomming
0 REM slave connection
@SLAVE 439
439 A = pioget($8[8]-48);
440 IF A <> 1 THEN 468;
441 IF $9[1] = 48 THEN 443;
442 PRINTS "@SLAVE\n\r";
443 IF $3[0] = 54 THEN 923;
0 REM if we are not on slave mode, then we must ignore slave connections :D

444 IF $3[0] > 50 THEN 466;
445 IF $3[0] > 48 THEN 447;
446 GOTO 466

447 A = getconn $7
0 REM if we are on service-slave, and the PIN was a success
0 REM then this is our peer.
448 IF $3[1] = 49 THEN 456
0 REM cable-slave-paired, check address
449 IF $3[0] = 50 THEN 453

0 REM set to paired no matter who cames
450 $3[0] = 50
451 $4 = $7
452 GOTO 456

0 REM check address of the connection and allow
453 $0 = $4
454 B = strcmp $7
455 IF B <> 0 THEN 466

0 REM slave connected
0 REM set interrupts to connected mode.
0 REM green and blue LEDS on
0 REM read sensors
456 A = nextsns 1
457 $22[2] = 50
458 B = pioset ($8[1]-48)
459 B = pioset ($8[0]-48)
0 REM set RS232 power to on
460 A = pioset ($8[4]-48)
0 REM DTR set on, +5V
461 A = pioclr ($8[5]-48)
0 REM set interrupts to connected mode.
462 A = pioirq $14
0 REM connect RS232 to slave
463 ALARM 0
464 C = link 1
465 RETURN

0 REM disconnect and exit
466 A = disconnect 0
467 RETURN

0 REM the user has selected to enabled the command line.
0 REM does he really want to get into?
468 TIMEOUTS 5
469 INPUTS $391
470 A = strlen $391
471 IF A < 3 THEN 441
472 IF $391[A-3] <> 43 THEN 441
473 IF $391[A-1] <> 43 THEN 441
474 GOTO 572

@MASTER 475
0 REM successful master connection
475 IF $9[1] = 48 THEN 477
476 PRINTS "@MASTER\n\r";
477 IF $3[0] > 52 THEN 898
0 REM if we are on manual master, then we have some requests
478 IF $3[3] <> 52 THEN 486

0 REM manual mode master
479 $3[3] = 54
480 A = pioset ($8[1]-48);
481 A = pioset ($8[0]-48);
482 PRINTS"\n\rCONNECTED\n\r"
483 A = link 3
484 ALARM 5
485 RETURN

0 REM if we are not on master modes, then we must avoid this connection.
486 IF $3[0] > 50 THEN 489;
487 IF $3[0] > 48 THEN 501;
488 IF $3[0] = 48 THEN 501;
489 A = pioset ($8[1]-48);
490 A = pioset ($8[0]-48);
0 REM don't switch state in service mode
491 IF $3[1] = 49 THEN 493
0 REM set state master paired
492 $3[0] = 52

0 REM read sensors
493 A = nextsns 1
494 $22[2] = 50
495 A = pioset ($8[4]-48);
0 REM DTR set on
496 A = pioclr ($8[5]-48);
0 REM link
497 A = link 2
0 REM look for disconnect
498 ALARM 5
0 REM allow DSR interrupts
499 A = pioirq $14
500 RETURN

501 A = disconnect 1
502 RETURN

0 REM $503 RESERVED
503 RESERVED
0 REM inquiry code, only in mode pair_as_master
@INQUIRY 504
504 $503 = $0
505 IF $9[1] = 48 THEN 507
506 PRINTS "@INQUIRY\n\r";
507 IF $3[3] <> 51 THEN 512
508 PRINTS"\n\rFound device: "
509 PRINTS $503
510 ALARM 4
511 RETURN

512 $4 = $503;
513 $503 = $0[13];
514 IF $3[0] <> 51 THEN 517;
0 REM inquiry filter active
515 IF $3[2] = 48 THEN 517;
516 GOTO 518
517 RETURN

518 IF $9[1] = 48 THEN 521;
519 PRINTS "found "
520 PRINTS $4
0 REM check name of device
521 $0[0]=0;
522 PRINTV $503;
523 B = strcmp $5;
524 IF B <> 0 THEN 531;

0 REM found one, try to connect, inquiry canceled automaticall
0 REM 447 GOSUB 485;
525 B = master $4;
0 REM if master busy keep stored address in $4, get next
526 IF B = 0 THEN 532;
0 REM master accepted, store address, restart alarms, give it 8 seconds to connect
0 REM corrected by mn
527 $7 = $4;
528 ALARM 8;
0 REM all on to indicate we have one
529 A = pioset ($8[1]-48);
530 A = pioset ($8[0]-48);
531 RETURN

0 REM get next result, give the inq result at least 2 sec time
532 GOSUB 534;
533 RETURN

0 REM blink sub-routine pair as master mode, blue-on green-off and reverse
534 IF J = 1 THEN 539;
535 J = 1;
536 A = pioset ($8[0]-48);
537 A = pioclr ($8[1]-48);
538 RETURN
539 A = pioclr ($8[0]-48);
540 A = pioset ($8[0]-48);
541 J = 0;
542 RETURN;

@CONTROL 543
0 REM remote request for DTR pin on the RS232
543 IF $0[0] < 128 THEN 546
544 A = uartcfg$0[0]
545 RETURN
546 IF $0[0] = 49 THEN 548;
547 A=pioset ($8[5]-48);
548 RETURN;
549 A=pioclr ($8[5]-48);
550 RETURN

@UART 551
551 IF $9[1] = 48 THEN 544
552 PRINTS"@UART\n\r
553 $0[0] = 0;
554 TIMEOUTU 5
555 INPUTU $0;
556 A = strlen $0;
557 IF $0[A-3] <> 43 THEN 551
0 REM command line interface active
558 IF $0[A-1] = 43 THEN 560

559 RETURN

560 $3[3] = 49
561 ALARM 1
562 A = enable 3
563 RETURN

0 REM read from Service slave.
0 REM result is on $529
0 REM 564 RESERVED FOR TEMP
564 RESERVED
565 $564[0] = 0;
566 TIMEOUTS 10
567 INPUTS $564
568 A = strlen $564
569 IF A > 0 THEN 571
570 GOTO 566
571 RETURN

0 REM command line interface
572 ALARM 0
573 A = pioirq $14
574 A = pioclr ($8[0]-48);
575 A = pioclr ($8[1]-48);
576 $3[3] = 49
0 REM enable FTP again
577 A = enable 3
578 PRINTS "\r\nAIRcable OS "
579 PRINTS "command line v
580 PRINTS $1
581 PRINTS "\r\nType h to "
582 PRINTS "see the list of "
583 PRINTS "commands";
584 PRINTS "\n\rAIRcable> "
585 GOSUB 565;

0 REM h: help, l: list,
0 REM n: name, p: pin, b: name filter, g: address filter
0 REM c: class of device, u: uart, d: date,
0 REM s: slave, i: inquiry, m: master, a: mode
0 REM o: obex
0 REM e: exit

0 REM help
586 IF $564[0] = 104 THEN 727;
0 REM info
587 IF $564[0] = 108 THEN 621;
0 REM name
588 IF $564[0] = 110 THEN 742;
0 REM pin
589 IF $564[0] = 112 THEN 747;
0 REM class
590 IF $564[0] = 99 THEN 751;
0 REM uart
591 IF $564[0] = 117 THEN 644;
0 REM date
592 IF $564[0] = 100 THEN 777;
0 REM inquiry
593 IF $564[0] = 105 THEN 846;
0 REM shell
594 IF $564[0] = 115 THEN 960;
0 REM master
595 IF $564[0] = 109 THEN 855;
0 REM obex
596 IF $564[0] = 111 THEN 787;
0 REM modes
597 IF $564[0] = 97 THEN 672;
0 REM exit
598 IF $564[0] = 101 THEN 612;
0 REM name filter
599 IF $564[0] = 98 THEN 767;
0 REM addr filter
600 IF $564[0] = 103 THEN 772;
0 REM hidden debug settings
601 IF $564[0] = 122 THEN 608;
0 REM reboot
602 IF $564[0] = 114 THEN 807;
0 REM relay mode pair
603 IF $564[0] = 106 THEN 871;
0 REM name/pin settings
604 IF $564[0] = 107 THEN 814;
0 REM PIO settings
605 IF $564[0] = 113 THEN 962
606 PRINTS"Command not found
607 GOTO 584;

608 PRINTS"Input settings: "
609 GOSUB 565
610 $9 = $564
611 GOTO 976

0 REM exit code, we end with slave-1 to ensure
0 REM that @SLAVE starts all again, and that
0 REM we start unvisible
612 PRINTS "Bye!!\n\r
613 GOSUB 136;
614 $3[3] = 48;
615 A = slave -1
616 A = disconnect 0
617 A = zerocnt
618 A = pioset($8[1]-48);
619 M = 0
620 RETURN

0 REM ----------------------- Listing Code ------------------------------------
621 PRINTS"Command Line v
622 PRINTS $1
623 PRINTS"\n\rName: ";
624 PRINTS $10;
625 PRINTS"\n\rPin: ";
626 PRINTS$11;
627 A = psget 0;
628 PRINTS"\n\rClass: ";
629 PRINTS $0;
630 PRINTS"\n\rBaud Rate: "
631 GOSUB 666
632 PRINTS"\n\rDate: ";
633 A = date $0;
634 PRINTS $0;
635 A = getaddr;
636 PRINTS"\n\rBT Address:
637 PRINTS $0
638 PRINTS"\n\rName Filter:
639 PRINTS $5;
640 PRINTS"\n\rAddr Filter:
641 PRINTS $6;
642 GOSUB 706
643 GOTO 584;

644 PRINTS"Enter new Baud Ra
645 PRINTS"te divide by 100,
646 PRINTS"or 0 for switches
647 PRINTS": "
648 GOSUB 565
649 $15 = $564
650 PRINTS"\n\r"
651 PRINTS"Parity settings:\n
652 PRINTS"\r0 for none\n\r
653 PRINTS"1 for even\n\r
654 PRINTS"2 for odd: "
655 GOSUB 565
656 A = $564[0]
657 $22[0] = A
658 PRINTS"\n\rStop Bits settin"
659 PRINTS"gs:\n\r0 for 1 stop
660 PRINTS" bit\n\r1 for 2 stop
661 PRINTS" bits:
662 GOSUB 565
663 A = $564[0]
664 $22[1] = A
665 GOTO 584

666 IF $15[0] = 48 THEN 670
667 PRINTS $15
668 PRINTS "00 bps
669 RETURN
670 PRINTS "External
671 RETURN

0 REM -------------------------- Modes chooser --------------------------------
0 REM the user should select between
0 REM 0: Manual
0 REM 1: Service Slave
0 REM 2: Service Master
0 REM 3: Cable Slave
0 REM 4: Cable Master
0 REM 5: Master Relay Mode
0 REM Mode:
672 PRINTS"Select new mode\n
673 PRINTS"\r0: Manual\n\r1:
674 PRINTS" Service Slave\n
675 PRINTS"\r2: Service Mast
676 PRINTS"er\n\r3: Cable Sl
677 PRINTS"ave\n\r4: Cable M
678 PRINTS"aster\n\rMode: "
679 GOSUB 565;
680 IF $564[0] = 48 THEN 687;
681 IF $564[0] = 49 THEN 690;
682 IF $564[0] = 50 THEN 694;
683 IF $564[0] = 51 THEN 698;
684 IF $564[0] = 52 THEN 702;
685 PRINTS"\n\rInvalid Option
686 GOTO 584;

687 $3[0]=48;
688 $3[3]=49;
689 GOTO 584;
690 $3[0] = 49;
691 $3[1] = 49;
692 $3[3] = 48;
693 GOTO 584;
694 $3[0] = 51;
695 $3[1] = 49;
696 $3[3] = 48;
697 GOTO 584;
698 $3[0] = 49;
699 $3[1] = 48;
700 $3[3] = 48;
701 GOTO 584;
702 $3[0] = 51;
703 $3[2] = 49;
704 $3[3] = 48;
705 GOTO 584;

0 REM -------------------------- Listing code ---------------------------------
706 PRINTS "\n\rMode: "
707 IF $3[0] > 52 THEN 725
708 IF $3[0] = 48 THEN 723
709 IF $3[1] = 48 THEN 712
710 PRINTS"Service - "
711 GOTO 713;
712 PRINTS"Cable - "
713 IF $3[0] >= 51 THEN 716;
714 PRINTS"Slave"
715 GOTO 717;
716 PRINTS"Master"
717 IF $3[0] = 50 THEN 721;
718 IF $3[0] = 52 THEN 721;
719 PRINTS"\n\rUnpaired"
720 RETURN
721 PRINTS"\n\rPaired"
722 RETURN
723 PRINTS"Idle"
724 RETURN
725 PRINTS"Relay Mode Master
726 RETURN

0 REM ----------------------- Help code ---------------------------------------
0 REM h: help, l: list,
0 REM n: name, p: pin, k: name/pin settings, 
0 REM b: name filter, g: address filter,
0 REM c: class of device, u: uart, d: date,
0 REM i: inquiry, m: master, a: mode,
0 REM o: obex, f: obexftp, j: relay mode pair,
0 REM e: exit, r: reboot, s: shell,
0 REM q: PIO settings
727 PRINTS"h: help, l: list,\n"
728 PRINTS"\rn: name, p: pin, "
729 PRINTS"k: name/pin setting"
730 PRINTS"s,\n\rb: name filte"
731 PRINTS"r, g: address filte"
732 PRINTS"r,\n\rc: class of d"
733 PRINTS"evice, u: uart, d: "
734 PRINTS"date,\n\ri: inquiry"
735 PRINTS", m: master, a: mode"
736 PRINTS",\n\ro: obex, "
737 PRINTS"j: relay mode "
738 PRINTS"pair,\n\re: exit, r:"
739 PRINTS" reboot, s: shell,\n"
740 PRINTS"\rq: PIO settings"
741 GOTO 584;

0 REM Name Function
742 PRINTS"New Name: "
743 GOSUB 565;
744 $10 = $564;
745 GOSUB 951
746 GOTO 584

0 REM Pin Function
747 PRINTS"New PIN: ";
748 GOSUB 565;
749 $11 = $564;
750 GOTO 584

751 PRINTS"Type the class of "
752 PRINTS"device as xxxx xxx"
753 PRINTS"x: "
754 GOSUB 565
755 $0[0] = 0;
756 PRINTV"@0000 =
757 PRINTV$564;
758 $564 = $0;
759 A = psget 0;
760 $562 =$0
761 $0[0]=0;
762 PRINTV $564;
763 $564 = $562[17]
764 PRINTV $564;
765 A = psset 3
766 GOTO 584

0 REM friendly name filter code
767 PRINTS"\r\rEnter the new na"
768 PRINTS"me filter: "
769 GOSUB 565
770 $5 = $564
771 GOTO 584;

0 REM addr filter code
772 PRINTS"Enter the new addr"
773 PRINTS"ess filter: "
774 GOSUB 565
775 $6 = $564
776 GOTO 584

0 REM date changing methods
777 PRINTS"Insert new dat
778 PRINTS"e, check the manua
779 PRINTS"l for formating: "
780 GOSUB 565;
781 A = strlen $564
782 IF A <> 16 THEN 785
783 A = setdate $564
784 GOTO 584
785 PRINTS"\n\rInvalid format
786 GOTO 584

0 REM activate Obex/ObexFTP
0 REM 0 Enabled only on command line
0 REM 1 Always enabled
0 REM 2 Always Disabled
787 PRINTS"Obex/ObexFTP setti"
788 PRINTS"ngs:\n\r0: Enabled "
789 PRINTS"only on command li"
790 PRINTS"ne\n\r1: Always Ena"
791 PRINTS"bled\n\r2: Always D"
792 PRINTS"isabled\n\rChoose "
793 PRINTS"Option: "
794 GOSUB 565
795 $9[2] = $564[0]
796 IF $564[0] = 50 THEN 802
797 $0[0] = 0
798 A = psget 6
799 $0[11] = 48
800 A = psset 3
801 GOTO 584
802 $0[0] = 0
803 A = psget 6
804 $0[11] = 54
805 A = psset 3
806 GOTO 584

0 REM reboot code
807 PRINTS"Rebooting, please "
808 PRINTS"do not disconnect "
809 PRINTS"electric power\n\r
810 $3[3] = 48
811 A = reboot
812 WAIT 2
813 RETURN

0 REM name/pin settings:
0 REM 0: Don't add anything,
0 REM 1: Add uniq to the name,
0 REM 2: Add uniq to the name, set pin to uniq.
814 PRINTS"Name/Pin settings:\n"
815 PRINTS"\r0: Don't add anyth"
816 PRINTS"ing,\n\r1: Add uniq "
817 PRINTS"to the name,\n\r2: "
818 PRINTS"Add uniq to the nam"
819 PRINTS"e, set pin to uniq: "
820 GOSUB 565
821 IF $564[0] < 48 THEN 825
822 IF $564[0] > 50 THEN 825
823 $23 = $564
824 GOTO 584

825 PRINTS"Invalid Option\n\r"
826 GOTO 814

0 REM ---------------------- Manual Modes code --------------------------------

827 PRINTS "\n\rThere is BT
828 PRINTS "activity, please
829 PRINTS "wait and try agai
830 PRINTS "n
831 GOTO 584;

0 REM ALARM for Manual modes, simply go to the command line.
0 REM we will not have leds any more.
832 IF $3[3] = 54 THEN 841
833 $3[3] = $3[5];
834 A = pioclr ($8[0]-48);
835 A = pioclr ($8[1]-48);
836 $3[3] = 49
837 ALARM 0
838 A = cancel
839 A = disconnect 1
840 GOTO 584

841 A = status
842 IF A > 10 THEN 844
843 GOTO 833

844 ALARM 5
845 RETURN

0 REM inquiry code
0 REM by default we inquiry for 10 seconds
846 GOSUB 932;
847 IF $39[0] = 49 THEN 827
848 PRINTS"Inquirying for "
849 PRINTS"16s. Please wait.
850 B = inquiry 10
851 $3[5] = $3[3];
852 $3[3] = 51;
853 ALARM 16
854 RETURN

0 REM master code
855 GOSUB 932;
856 IF $39[3] = 49 THEN 827
857 PRINTS"Please input "
858 PRINTS"the addr of your "
859 PRINTS"peer:
860 GOSUB 565
861 B = strlen$564
862 IF B<>12 THEN 868
863 $3[5] = $3[3]
864 B = master $564
865 ALARM 16
866 $3[3] = 52;
867 RETURN

868 PRINTS"Invalid add
869 PRINTS"r, try again.
870 GOTO 584;

0 REM ---------------------------- RELAY CODE ----------------------------------

0 REM relay mode pair
0 REM Enter the address of your peer: 
871 PRINTS"Enter the address "
872 PRINTS"of your peer: "
873 GOSUB 565;
874 A = strlen $564;
875 IF A = 12 THEN 878;
876 PRINTS"\n\rNot valid peer
877 GOTO 584
878 PRINTS"\n\rTrying to pair
879 $3[5] = $3[3];
880 $3[3] = 48;
881 $20 = $564
882 A = master $20
883 $3[0] = 53
884 ALARM 16
885 RETURN

0 REM relay mode alarm handler
0 REM first check for command line
886 IF $3[3] <> 48 THEN 572
887 ALARM 5
888 IF $3[0] = 53 THEN 832
889 B = status
890 IF $3[0] = 54 THEN 320
891 IF B < 1 THEN 317
892 IF $3[0] = 55 THEN 327
893 IF B > 10 THEN 368
894 A = disconnect 0
895 A = disconnect 1
896 $3[0] = 54
897 GOTO 551

898 IF $3[0] = 53 THEN 905
899 A = pioset ($8[1]-48);
900 A = pioset ($8[0]-48);
901 $3[0] = 56
902 A = link 3;
903 ALARM 4
904 RETURN
905 $3[0]=54
906 A = disconnect 1
907 PRINTS"\n\rPair successfull"
908 PRINTS"\n\rPlease choose "
909 PRINTS"which kind of relay "
910 PRINTS"you want:\n\r1: Serv"
911 PRINTS"ice Relay\n\r2: Cabl"
912 PRINTS"e Relay\n\rMode: "
913 ALARM 0
914 GOSUB 565
915 IF $564[0] = 49 THEN 919
916 IF $564[0] = 50 THEN 919
917 PRINTS"\n\rInvalid Option
918 GOTO 908
919 A = $564[0];
920 $3[4] = A;
921 $3[0] = 54;
922 GOTO 584

923 $3[0] = 55
924 GOTO 326

925 B = readcnt;
926 IF $3[4] = 50 THEN 929
927 A = slave 8
928 RETURN
929 IF B < 120 THEN 927
930 A = slave -8
931 RETURN


0 REM -------------------------- END RELAY CODE --------------------------------

0 REM convert status to a string
0 REM store the result on $44
932 B = status
933 $39[0] = 0;
934 $39 = "00000";
935 IF B < 10000 THEN 938;
936 $39[0] = 49;
937 B = B -10000;
938 IF B < 1000 THEN 941;
939 $39[1] = 49;
940 B = B -1000;
941 IF B < 100 THEN 944;
942 $39[2] = 49;
943 B = B -100;
944 IF B < 10 THEN 947;
945 $39[3] = 49;
946 B = B -10;
947 IF B < 1 THEN 949;
948 $39[4] = 49;
949 $39[5] = 0;
950 RETURN

951 $0[0] = 0;
952 PRINTV $10;
953 IF $23[0] = 48 THEN 957
0 REM this line is used by all the other devices.
0 REM REMEMBER TO UPDATE NUMBER, last was 955
955 GOSUB 978
956 PRINTV $39;
957 A = name $0;
958 RETURN

959 $3[0] = 48
960 A = shell
961 RETURN

962 PRINTS"Please Input PIO set"
963 PRINTS"tings.\n\rPlease che"
964 PRINTS"ck DOCs for More Inf"
965 PRINTS"ormation: "
966 GOSUB 565
967 A = strlen $564
968 IF A < 10 THEN  972
969 $12 = $564
970 $8 = "Z"
971 GOTO 807
972 PRINTS"Option is invalid, C"
973 PRINTS"heck the DOCs again"
974 PRINTS"\n\r"
975 GOTO 584

976 Z = $9[0]-48
977 GOTO 584

978 PRINTV"_v"
980 $39 = $1
981 RETURN

982 B = status
983 IF B > 0 THEN 989
0 REM to show the user the command line can be accessed, we do a long blink
984 A = pioset($8[1]-48);
985 A = pioset($8[0]-48)
986 A = pioclr($8[0]-48);
987 A = slave 5
988 RETURN

989 ALARM 5
990 RETURN

991 $3[3] = 48
992 GOTO 342

