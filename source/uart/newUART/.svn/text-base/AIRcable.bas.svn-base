@ERASE

0 REM this is the base code for all the AIRcable OS products
0 REM we take the AIRcable SMD/Mini as our base device

0 REM let's reserve the first 30 lines for internal stuff

0 REM $1 is the version of the command line
1 0.9UART

0 REM defaults setting for mode
0 REM uncomment the one you want to use as default
0 REM service slave UART
2 11100
0 REM service master UART 31100
0 REM cable slave UART 10100
0 REM cable master UART 30100
0 REM idle UART 00100
0 REM service slave SPP 11101
0 REM service master SPP 31101
0 REM cable slave SPP 10101
0 REM cable master SPP 30101
0 REM idle SPP 00101


0 REM $3 stores the mode configuration
0 REM $3[0] = 0 48 means idle
0 REM $3[0] = 1 49 means pairing as slave
0 REM $3[0] = 2 50 means paired as slave
0 REM $3[0] = 3 51 means pairing as master
0 REM $3[0] = 4 52 means paired as master

0 REM $3[1] = 0 48 cable mode
0 REM $3[1] = 1 49 service mode

0 REM $3[2] = 0 48 device found / module paired
0 REM $3[2] = 1 49 inquiry needed

0 REM $3[3] = 0 48 means automatic
0 REM $3[3] = 1 49 means manual idle.
0 REM $3[3] = 2 50 manual slave, connecting
0 REM $3[3] = 3 51 manual inq
0 REM $3[3] = 4 52 manual master, connecting
0 REM $3[3] = 5 53 manual slave, connected
0 REM $3[3] = 6 54 manual master, connected

0 REM if var K = 1 then we must do a slave-1

0 REM $4 IS RESERVED FOR PAIRED ADDR
4 0

0 REM $5 stores the name of the devices we only want during inquiry
5 AIR

0 REM $6 stores the filter address we filter on during inquiry
6 0050C2

0 REM $7 for paired master addresses
7 0

0 REM $8 stores the pio settings
0 REM $8[0] BLUE LED
0 REM $8[1] GREEN LED
0 REM $8[2] BUTTON
0 REM $8[3] RS232 POWER OFF
0 REM $8[4] RS232 POWER ON
0 REM $8[5] DTR
0 REM $8[6] DSR
0 REM $8[7] POWER SWITCH
0 REM $8[8] COMMAND LINE PIN
0 REM $8[9] BATTERY MEASURMENT ENABLED 0 - 1
0 REM LINE $12 STORES THE DEFAULT VALUE
0 REM z means unitializated
8 z

0 REM Debug settings
0 REM first char is for Z enabled/disabled
0 REM second char is for shell
0 REM third is for dumping states
0 REM fourth for Obex/ObexFTP
0 REM 0 48 Enabled only on command line
0 REM 1 49 Always enabled
0 REM 2 50 Always Disabled
9 0000

0 REM $10 stores our friendly name
10 AIRcable

0 REM $11 stores our PIN
11 1234

0 REM DEFAULT pio settings IN ORDER
0 REM BLUE LED
0 REM GREEN LED
0 REM BUTTON
0 REM RS232 POWER OFF
0 REM RS232 POWER ON
0 REM DTR
0 REM DSR
0 REM POWER SWITCH
12 K0000000

0 REM PIO_IRQ SETTINGS@
0 REM $13 Button + Power Switch + Command Line. For no connections
0 REM autogenerated in first bootup
13 0
0 REM $14 button + DSR interrupt + Power Switch. While connected
0 REM autogenerated in first bootup
14 0

0 REM $15 PIO_IRQ for off mode, only Power Switch measurment.
15 0

0 REM 15 is the settings for the uart when a connection is made
0 REM 0 means read from dip swithces
0 REM any other number is converted to an int.
16 1152

0 REM 22 Parity Settings
0 REM [0] = "0" = none
0 REM "1" = even
0 REM "2" = odd
0 REM [1] = "0" 1 stop bit
0 REM "1" 2 stop bits
17 00

0 REM 16 this is the time that the Obex/ObexFTP will be available after
0 REM boot up
18 120

0 REM on variable I we store the baud rate setting.
0 REM this variable is initializated by @SENSOR

0 REM 19 unique settings
0 REM [0] = "0" don't add nothing
0 REM [0] = "1" add unique name
0 REM [0] = "2" add unique name, generate pin
19 1

0 REM 20 service master counter
20 0

0 REM $39 RESERVED
39 RESERVED


0 REM _________________SORT OF XATOI

0 REM THIS TURNS A CHAR AT $0[E] into
0 REM and integer in F
40 IF $0[E] > 57 THEN 43
41 F = $0[E] - 48;
42 RETURN
0 REM WE NEED TO ADD 10 BECAUSE "A" IS NOT 0
0 REM IS 10
43 F = $0[E] - 55;
44 RETURN


0 REM ___INIT
0 REM sets Z, baud rate for command line, PIO list
@INIT 45
45 Z = $9[0] - 48;
46 A = baud 1152

0 REM Check PIO list
47 IF $8[0] <> 122 THEN 71
48 $0[0] = 0
49 PRINTV $12
50 FOR E = 0 TO 9
51 GOSUB 40
52 $8[E] = F + 48
53 NEXT E
54 $8[E+1] = 0

0 REM start PIO_IRQ strings
55 $0[0] = 0;
56 PRINTV"P000000000000";
57 $13 = $0;
58 $14 = $0;
59 $15 = $0;

60 IF $8[2] = 48 THEN 63;
61 $13[$8[2]-48] = 49;
62 $14[$8[2]-48] = 49;
63 IF $8[6] = 48 THEN 65;
64 $14[$8[6]-48] = 49;
65 IF $8[7] = 48 THEN 69;
66 $13[$8[7]-48] = 49;
67 $14[$8[7]-48] = 49;
68 $15[$8[7]-48] = 49;
69 IF $8[8] = 48 THEN 73;
70 $13[$8[8]-48] = 49;

71 $0[0] = 0;
72 PRINTV $10;
73 IF $19[0] = 48 THEN 77
74 PRINTV " ";
75 A = getuniq $39;
76 PRINTV $39;
77 A = name $0;

0 REM H = 0	booted
0 REM H = 1	booting
78 H = 1

0 REM __initializate PIOs

0 REM button as input
79 A = pioin ($8[2]-48);
0 REM bias pull up to high
80 A = pioset ($8[2]-48);
0 REM green LED output, off
81 A=pioout ($8[1]-48);
82 A=pioclr ($8[1]-48);
0 REM blue LED output, off
83 A=pioout ($8[0]-48)
0 REM RS232_off set, switch on RS232
84 A=pioout ($8[3]-48)
85 A=pioset ($8[3]-48)
0 REM RS232_on power on, switch to automatic later
86 A=pioout ($8[4]-48)
87 A=pioset ($8[4]-48)
0 REM DTR output set -5V
88 A=pioout ($8[5]-48)
89 A=pioset ($8[5]-48)
0 REM DSR input
90 A=pioin ($8[6]-48)

0 REM reset for pairing timeout
91 A = zerocnt

0 REM state initialize
92 IF $3[0] <> 90 THEN 94
0 REM newly updated BASIC program, goto default mode
93 $3 = $2;

0 REM init button state
0 REM w = 0 no button pressed
94 W = 0

0 REM in idle mode we wait for a command line interface start
0 REM you must type a +++ and enter
0 REM blue LED off
95 A = pioclr ($8[0]-48)
96 J = 0

97 $3[3] = 48;

0 REM check power state
98 A = pioset($8[7] -48)
99 A = pioin ($8[7] -48)
100 IF A = 0 THEN 115

0 REM let's start up, green LED on
101 A = pioset ($8[1]-48)

102 K = 1
0 REM now we go to @IDLE, and then we get into the @ALARM
103 A = uartint

0 REM start pio_irq
104 A = pioirq $13
0 REM N = 0	battery OK
0 REM N = 1	battery empty
106 N = 0
107 L = 1
0 REM M = 1 power = ON.
108 M = 0
109 A = nextsns 1
110 RETURN

0 REM TURN off function
115 M = 1;
116 ALARM 0;
117 A = nextsns 0;
118 A = pioclr ($8[0]-48);
119 A = pioclr ($8[1]-48);
120 A = pioclr ($8[2]-48);
121 A = pioclr ($8[3]-48);
122 A = pioclr ($8[4]-48);
123 A = pioclr ($8[5]-48);
124 A = pioclr ($8[6]-48);
125 A = slave -1;
126 A = disable 3
127 A = pioirq $21;
128 RETURN

0 REM ______________________ Sensor
@SENSOR 150
0 REM check battery state
150 IF $8[9] = 48 THEN 161;
151 A = sensor $0;
152 V = atoi $0[5];
153 IF V < 3000 THEN 157;

0 REM battery is OK
154 N = 0;
155 A = nextsns 600;
156 GOTO 128;

157 N = 1;

0 REM if connected set baud rate
158 IF $3[3] <> 48 THEN 161;
159 A = status
160 IF A > 0 THEN 162
161 RETURN;

0 REM baud rate selector switch implementation
0 REM thresholds (medians) for BAUD rate switch
0 REM AIO0 has voltage, use 1000 (3e8) as analog correction factor
0 REM if it is smaller than this, then switch is set
0 REM first switch: 1 - SLAVE 0 - MASTER ONLY READ IN BOOT
0 REM voltages < 930 are consider master
0 REM rest:
0 REM voltages: 160,  450,   650,   810, 
0 REM           930,  1020,  1090,  >
0 REM switch    111,  110,   101,   100, 
0 REM           011,  010,   001,   000
0 REM baud:    1152,  96,    384,   576
162 IF $15[0] = 48 THEN 1;
0 REM we need to convert from string to integer, because we are on internal
0 REM baud rate, if an error ocurs while converting, then we switch
0 REM to the dip's automatically
163 C = atoi $15;
164 IF C = 0 THEN 167;
165 I = C;
166 GOTO 190
167 C = sensor $0;
168 IF H = 0 THEN 175
0 REM change mode
169 IF C < 930 THEN 172
170 IF $3[0] = 52 THEN 175
171 $3[0] = 52
172 $4 = "0
173 GOTO 175

174 $3[0] = 49

175 IF C < 160 THEN 184
176 IF C < 450 THEN 186
177 IF C < 650 THEN 188
178 IF C < 810 THEN 182 
179 IF C < 930 THEN 184
180 IF C < 1020 THEN 186
181 IF C < 1090 THEN 188
182 I = 576;
183 GOTO 190;

184 I = 1152
185 GOTO 190

186 I = 96
187 GOTO 190

188 I = 384
189 GOTO 190

190 IF I = 12 THEN 204
191 IF I = 24 THEN 206
192 IF I = 48 THEN 208
193 IF I = 96 THEN 210
194 IF I = 192 THEN 212
195 IF I = 384 THEN 214
196 IF I = 576 THEN 216
197 IF I = 769 THEN 218
198 IF I = 1152 THEN 220
199 IF I = 2304 THEN 222
200 IF I = 4608 THEN 224
201 IF I = 9216 THEN 226
202 IF I = 13824 THEN 228
0 REM wrong settings for baud rate, we don't have a fixed value, we can't do
0 REM parity and stop bits
203 GOTO 241

204 I = 0
205 GOTO 229
206 I = 1
207 GOTO 229
208 I = 2
209 GOTO 229
210 I = 3
211 GOTO 229
212 I = 4
213 GOTO 229
214 I = 5
215 GOTO 229
216 I = 6
217 GOTO 229
218 I = 7
219 GOTO 229
220 I = 8
221 GOTO 229
222 I = 9
223 GOTO 229
224 I = 10
225 GOTO 229
226 I = 11
227 GOTO 229
228 I = 12
229 IF $22[0] = 49 THEN 232
230 IF $22[0] = 50 THEN 234
231 GOTO 235
232 I = I + 64
233 GOTO 235
234 I = I + 32
235 IF $22[1] = 49 THEN 238
236 GOTO 238
237 I = I + 16
238 I = I + 128
239 A = uartcfg I
240 RETURN

241 A = baud I
242 RETURN


